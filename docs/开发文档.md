# 订单管理系统开发文档

## 📋 项目信息
| 项目名称 | 订单管理系统(demo)|
|---------|--------------------------------------|
| 技术栈 | Go 1.21.4 + Gin + GORM + MySQL + Redis|
| 开发周期 | 2天 |
| 负责人 | [马瑞] |
| 最后更新 | 2024年1月X日 |
| 项目状态 | 开发完成，待演示 |

---

## 🎯 项目背景

### 开发需求
- 能够解决并发问题
- 能够结合数据结构特性设计model
- 理清楚gin框架开发的go web项目全流程
- 具备开发简单接口的能力 熟悉go语言开发规范

### 技术挑战
- 高并发场景下的数据一致性
- 库存超卖问题
- 系统性能优化
- 并发控制机制设计

---

## 🏗️ 技术架构

### 系统架构图
![系统架构图](/pictures/image.png)
### 技术选型说明
| 技术 | 版本 | 用途 | 优势 |
|------|------|------|------|
| Go | 1.21.4 | 后端语言 | 高并发、高性能、内存安全 |
| Gin | v1.9.x | Web框架 | 轻量级、高性能、中间件丰富 |
| GORM | v1.25.x | ORM框架 | 简化数据库操作、支持事务 |
| MySQL | 8.0 | 主数据库 | 事务支持、数据一致性、索引优化 |
| Redis | 7.0 | 缓存 | 高性能缓存、支持多种数据结构 |
| Kafka | 3.x | 消息队列 | 异步处理、解耦、高吞吐量 |

### 项目结构
```
demo01/
├── cmd/                    # 应用程序入口
│   └── main.go            # 主程序
├── config/                 # 配置文件
│   └── config.go          # 配置管理
├── internal/               # 内部包
│   ├── handler/           # HTTP处理器
│   │   └── order_handler.go
│   ├── service/           # 业务逻辑层
│   │   └── order_service.go
│   ├── repository/        # 数据访问层
│   │   ├── order_repo.go
│   │   └── inventory_repo.go
│   ├── model/            # 数据模型
│   │   └── order.go
│   └── util/             # 工具函数
├── test/                  # 测试文件
│   └── test_order.json   # 测试数据
├── docs/                  # 文档
├── go.mod                 # 依赖管理
├── go.sum                 # 依赖校验
├── README.md              # 项目说明
└── .gitignore            # Git忽略文件
```

---

## 🚀 核心功能

### 1. 订单创建功能
**接口**：`POST /orders`
**功能描述**：支持批量商品下单，实现库存实时扣减

**请求示例**：
```json
{
  "user_id": "user_123",
  "items": [
    {
      "product_id": 1,
      "quantity": 2,
      "price": 99.99
    },
    {
      "product_id": 2,
      "quantity": 1,
      "price": 199.99
    }
  ]
}
```

**技术亮点**：
- 🔄 **并发控制**：使用 goroutine + WaitGroup + channel
- 🔒 **乐观锁**：版本号控制，防止超卖
- ⚡ **自旋重试**：8次重试 + 指数退避策略
- 💾 **缓存机制**：本地缓存 + Redis 双重缓存
- 📨 **异步消息**：Kafka 消息队列解耦

**性能指标**：
- 单线程响应时间：< 50ms
- 并发100成功率：> 95%
- 并发500成功率：> 85%

### 2. 订单查询功能
**接口**：
- `GET /orders/:id` - 查询单个订单
- `GET /orders` - 查询所有订单（支持分页）

**技术特点**：
- 🚀 **缓存优先**：本地缓存 → 数据库查询
- 📊 **分页支持**：避免大数据量查询
- 🔍 **索引优化**：订单ID主键索引

### 3. 库存管理功能
**核心算法**：乐观锁 + 自旋重试

**重试策略**：
```
重试次数: 8次
基础延迟: 5ms
指数退避: 5ms → 10ms → 20ms → 40ms → 50ms
最大延迟: 50ms
```

**状态流转**：
```
待处理 → 已支付 → 已发货 → 已送达
   ↓        ↓        ↓
已取消 ← 已取消 ← 已取消
```

**优势**：
- 避免悲观锁的性能瓶颈
- 智能重试提升成功率
- 指数退避减少数据库压力
- 支持Context超时控制

---

## 📊 性能测试

### 测试环境
- **硬件**：MacBook Pro M1
- **数据库**：MySQL 8.0
- **压测工具**：hey
- **并发用户**：100-500

### 测试结果
| 接口 | 并发数 | 成功率 | 平均响应时间 | QPS |
|------|--------|--------|-------------|-----|
| POST /orders | 100 | 96% | 45ms | 2,133 |
| POST /orders | 500 | 87% | 78ms | 5,577 |
| GET /orders/:id | 100 | 100% | 12ms | 8,333 |
| GET /orders/:id | 500 | 100% | 15ms | 33,333 |

### 性能优化效果
- **乐观锁优化前**：并发100成功率 60%
- **乐观锁优化后**：并发100成功率 96%
- **提升幅度**：36%

---

## 🔧 技术亮点

### 1. 并发控制机制
```go
// 使用 goroutine + WaitGroup + channel
var wg sync.WaitGroup
errChan := make(chan error, len(items))

for _, item := range items {
    wg.Add(1)
    go func(productID int, quantity int) {
        defer wg.Done()
        // 并发扣减库存
    }(item.ProductID, item.Quantity)
}
```

### 2. 乐观锁自旋重试
```go
// 指数退避策略
delay := baseDelay * time.Duration(1<<attempt)
if delay > maxDelay {
    delay = maxDelay
}
```

### 3. 缓存策略
```go
// 双重缓存：本地缓存 + Redis
s.rwLock.RLock()
if order, exists := s.localCache[orderID]; exists {
    return order, nil
}
s.rwLock.RUnlock()
```
